<t><list style="symbols">
  <t><xref target="introduction"></xref>
  <list style="symbols">
      <t><xref target="requirements-notation">Requirements Notation</xref></t>
    </list></t>
  <t><xref target="terminology"></xref></t>
  <t><xref target="requirements"></xref></t>
  <t><xref target="multi-signer-use-cases">Multi-Signer Use Cases</xref>
  <list style="symbols">
      <t><xref target="primary-use-case">Primary Use Case</xref></t>
      <t><xref target="secondary-use-case">Secondary Use Case</xref></t>
    </list></t>
  <t><xref target="the-distributed-multi-signer-model">The Distributed Multi-Signer Model</xref>
  <list style="symbols">
      <t><xref target="multi-signer-agent-signer-vs-sidecar">Multi-Signer Agent: Signer vs Sidecar</xref></t>
      <t><xref target="source-of-truth">Source of Truth</xref>
      <list style="symbols">
          <t><xref target="the-combiner">The COMBINER</xref></t>
        </list></t>
    </list></t>
  <t><xref target="communication-between-msas">Communication Between MSAs</xref>
  <list style="symbols">
      <t><xref target="msa-communication-via-rest-api">MSA Communication via REST API</xref></t>
      <t><xref target="msa-communication-via-dns">MSA Communication via DNS</xref></t>
    </list></t>
  <t><xref target="identifying-the-designated-signers">Identifying the Designated Signers</xref></t>
  <t><xref target="locating-remote-multi-signer-agents">Locating Remote Multi-Signer Agents</xref>
  <list style="symbols">
      <t><xref target="locating-a-remote-api-method-multi-signer-agent">Locating a Remote API-Method Multi-Signer Agent</xref></t>
      <t><xref target="locating-a-remote-dns-method-multi-signer-agent">Locating a Remote DNS-Method Multi-Signer Agent</xref></t>
    </list></t>
  <t><xref target="synchronization-of-changes-between-msas">Synchronization of Changes Between MSAs</xref>
  <list style="symbols">
      <t><xref target="leaderfollower-mode">Leader/Follower Mode</xref></t>
      <t><xref target="peer-mode">Peer Mode</xref></t>
    </list></t>
  <t><xref target="security-considerations">Security Considerations</xref></t>
  <t><xref target="iana-considerations">IANA Considerations.</xref></t>
  <t>    <section anchor="change-history-to-be-removed-before-publicationchange-history-to-be-removed-before-publication"><name><xref target="change-history-to-be-removed-before-publication">Change History (to be removed before publication)</xref></name>
  <vspace blankLines='1'/>
title: "Distributed DNSSEC Multi-Signer"
abbrev: "Distributed Multi-Signer"
docname: draft-leon-distributed-multi-signer-00
date: {DATE}
category: std</t>
</list></t>

<t>ipr: trust200902
area: Internet
workgroup: DNSOP Working Group
keyword: Internet-Draft</t>

<t>stand_alone: yes
pi: [toc, sortrefs, symrefs]</t>

<t>author:
 -
    ins: L. Fernandez
    name: Leon Fernandez
    organization: The Swedish Internet Foundation
    country: Sweden
    email: leon.fernandez@internetstiftelsen.se
 -
    ins: E. Bergström
    name: Erik Bergström
    organization: The Swedish Internet Foundation
    country: Sweden
    email: erik.bergstrom@internetstiftelsen.se
 -
    ins: J. Stenstam
    name: Johan Stenstam
    organization: The Swedish Internet Foundation
    country: Sweden
    email: johan.stenstam@internetstiftelsen.se</t>

<t>normative:</t>

<t>informative:</t>

<t>--- abstract</t>

<t>This document presents an architecture for a distributed DNS
multi-signer model. It describes two models for multi-signer process
traversal: “leader/follower mode” and “peer mode”. It also discusses
two alternatives for secure communication between the individual
multi-signer agents: a RESTful API secured by TLS and “pure DNS”
communication secured by DNS SIG(0) signatures on each message.</t>

<t>The scope of the document is only the distributed aspect of DNS
multi-signer. The so-called “multi-signer processes” are the same as
described in <xref target="!RFC8901"/>.</t>

<t>TO BE REMOVED: This document is being collaborated on in Github at:
<eref target="https://github.com/johanix/draft-leon-dnsop-distributed-multi-signer">https://github.com/johanix/draft-leon-dnsop-distributed-multi-signer</eref>.
The most recent working version of the document, open issues, etc, should all be
available there.  The authors (gratefully) accept pull requests.</t>

<t>--- middle</t>

</section>
<section anchor="introduction"><name>Introduction</name>

<t>The issue of how to eliminate so-called "single points of failure"
from systems to make them more robust is a recurring theme in systems
design and so also for DNS. In the DNS case redundancy is addressed by
having multiple name servers for the same zone. However, when the zone
is DNSSEC-signed there is traditionally an additional single point of
failure: the so-called "signer".</t>

<t>Multi-signer (<xref target="!RFC8901"/>) describes a process by which it is
possible to use more than one signer, by having the signers (or their
agents) communicate and exchange data that should be signed by the
other signer. The most obvious example is that each signer's
Key-Signing Key must sign a DNSKEY RRset that contains the
Zone-Signing Keys for all signers.</t>

<t>The communication between signers has two parts: first it is necessary
to find out what data each signer has for a zone. Once all data has
been collected it is possible to compute what changes are needed to
the zone data at each signer. That triggers the second phase where the
zone data for the individual signers is changed to get them in sync
with each other.</t>

<t>Knowledge of DNS NOTIFY <xref target="!RFC1996"/> and DNS Dynamic Updates
<xref target="!RFC2136"/> and <xref target="!RFC3007"/> is assumed. DNS SIG(0) transaction
signatures are documented in <xref target="!RFC2931"/>.</t>

<section anchor="requirements-notation"><name>Requirements Notation</name>

<t>The key words "<strong>MUST</strong>", "<strong>MUST NOT</strong>", "<strong>REQUIRED</strong>", "<strong>SHALL</strong>",
"<strong>SHALL NOT</strong>", "<strong>SHOULD</strong>", "<strong>SHOULD NOT</strong>", "<strong>RECOMMENDED</strong>",
"<strong>NOT RECOMMENDED</strong>", "<strong>MAY</strong>", and "<strong>OPTIONAL</strong>" in this document
are to be interpreted as described in BCP 14 <xref target="!RFC2119"/> <xref target="!RFC8174"/>
when, and only when, they appear in all capitals, as shown here.</t>

</section>
</section>
<section anchor="terminology"><name>Terminology</name>

<t>...</t>

</section>
<section anchor="requirements"><name>Requirements</name>

<t>The requirements for an architecture for distributed multi-signer are
defined as follows:</t>

<t><list style="symbols">
  <t>Assuming all zone transfers are correctly set up, a zone owner MUST
be able to signal to the individual multi-signer providers
information sufficient for the providers to identify each other and
establish secure communication.</t>
  <t>The zone owner MUST be able to signal the intent to onboard an
additional multi-signer provider. This must automatically initiate
the multi-signer “add signer” process, as described in RFC nnnn.</t>
  <t>The zone owner MUST be able to signal the intent to offboard an
existing multi-signer provider. This MUST automatically initiate
the multi-signer “remove signer” process, as described in RFC nnnn.</t>
  <t>All signalling from zone owner to multi-signer providers SHOULD be
carried out via data in the served zone, to ensure that all
providers get the same configuration information at (almost) the
same time.</t>
  <t>By engaging a set of multi-signer providers (one or more), the zone
owner MUST give up control over the following records:
  <list style="symbols">
      <t>All DNSSEC related records in the zone</t>
      <t>The NS RRset</t>
      <t>Any CDS and/or CSYNC RRsets</t>
    </list></t>
</list></t>

</section>
<section anchor="multi-signer-use-cases"><name>Multi-Signer Use Cases</name>

<section anchor="primary-use-case"><name>Primary Use Case</name>

<t>The primary use case for the proposed multi-signer architecture is the
following scenario: A zone owner needs to remove the single point of
failure that the DNSSEC signer constitutes. For this reason it
contracts with two or more “multi-signer capable” service
providers. Each such service provider provides the following service:</t>

<t><list style="symbols">
  <t>Receive an unsigned zone via zone transfer.</t>
  <t>Locate all active signers via the MSIGNER RRset as published by the
zone owner. Establish secure communication with all remote signers
(or their agents).</t>
  <t>Update the NS, DNSKEY, CDS and CSYNC RRsets as needed, based on
synchronization with the remote signers (or their agents).</t>
  <t>Sign the zone, using own DNSKEYs, but with a published DNSKEY RRset
that includes the DNSKEYs of other signers.</t>
  <t>Distribute the signed zone to a set of downstream authoritative
nameservers.</t>
</list></t>

</section>
<section anchor="secondary-use-case"><name>Secondary Use Case</name>

<t>A slightly different use case is where a zone owner has a desire to
migrate from one DNSSEC provider to another. In the first step it
onboards the new provider by adding an MSIGNER RR with MSIGNER
State=“ON” identifying the new provider to the existing MSIGNER
RRset. This informs both the present providers and the incoming
provider about the addition of a new provider and the onboarding
process is automatically initiated.</t>

<t>Once the onboarding operation is completed it signals the pending
removal of another provider by changing the MSIGNER State flag for the
outgoing signer to “OFF”. This informs all the present providers about
the pending removal and the offboarding process is automatically
initiated.</t>

</section>
</section>
<section anchor="the-distributed-multi-signer-model"><name>The Distributed Multi-Signer Model</name>

<t>The primary difference between monolithic and distributed multi-signer
is that the former has a central “controller” while the latter
doesn’t. But there is still an absolute need for synchronization
between the different participants in the distributed multi-signer
setup.</t>

<t>There are three immediate aspects for the design of a distributed
multi-signer architecture:</t>

<t><list style="symbols">
  <t>The first is “synchronization”: who decides what changes are needed.</t>
  <t>The second is “method”: how to communicate between the individual
instances in a multi-signer system.</t>
  <t>The third is source of truth for different types of zone
data. The zone owner is the source of truth for all unsigned zone
data, except DNSSEC data and the NS RRset. The signer is the source
of truth for all DNSSEC data in the zone. In a distributed
multi-signer architecture the source of truth is</t>
</list></t>

<section anchor="multi-signer-agent-signer-vs-sidecar"><name>Multi-Signer Agent: Signer vs Sidecar</name>

<t>In a distributed setup there must be a service located with each
multi-signer “signer” that manages communication with other
signers. This is referred to as the multi-signer agent, or MSA.</t>

<t>It is possible to implement support for the synchronization and
communication needs directly into each “signer” (i.e. typically an
authoritative nameserver with the ability to do online DNSSEC
signing). In this case the signer implements the MSA functionality.</t>

<t>However, it is also possible to separate the multi-signer complexity
into a separate service, which is sometimes referred to as
“sidecar”. This term is used as this service sits next to the signer,
and is under the same administrative control, but is a separate piece
of software. When using this design each signer has a sidecar attached
next to it. The sidecars configured as a “secondary nameserver” that
receives the (signed) zone from the actual signer.</t>

<t>The “sidecar” design has the major advantage of leaving the signer
almost entirely out of the multi-signer complexity. The requirements
are only that the “signer” treats the “sidecar” as a normal secondary
(sends NOTIFY messages and responds to zone transfer requests) and
that the “sidecar” has a configuration that allows it to make changes
to zones that the “signer” serves (most commonly via TSIG-signed DNS
UPDATEs, but other models are possible).</t>

<t>In this document the design using a separate MSA (i.e. a “sidecar”) is
used, while pointing out that it is possible to integrate this into a
future “signer” that implements both DNSSEC signing and the MSA
requirements.</t>

</section>
<section anchor="source-of-truth"><name>Source of Truth</name>

<t>A very common design for DNSSEC signing (regardless of multi-signer)
is to use a separate, bump-on-the-wire signer. This is a signer that
receives the unsigned zone via an incoming zone transfer, signs the
zone, and publishes the signed zone via an outbound zone transfer. In
such a design the source of truth has been split up between the “zone
owner” (source of truth for all unsigned zone data), and the signer
(source of truth for all DNSSEC data in the zone).</t>

<t>In a distributed multi-signer architecture the source of truth is
further split up into three participants:</t>

<t><list style="symbols">
  <t>The zone owner is the source of truth for all unsigned zone data,
except DNSSEC data and the NS RRset.</t>
  <t>The signer is the source of truth for all data generated via DNSSEC
signing: own DNSKEYs, NSEC/NSEC3 RRs, RRSIGs, etc.</t>
  <t>The MSA is the source of truth for the RRsets that must be kept in
sync across all the signers for the zone. This includes the zone NS
RRset, DNSKEYs from other signers, CDS and CSYNC RRsets.</t>
</list></t>

<t>To be able to keep the signer as simple as possible the changes to the
NS, DNSKEY, CDS and CSYNC RRsets must be introduced into the unsigned
zone before the zone reaches the signer. Likewise, to keep the zone
owner as simple as possible (i.e. not involved in the details of the
multi-signer automation) these changes must be introduced into the
unsigned zone after the zone leaves the zone owner.</t>

<section anchor="the-combiner"><name>The COMBINER</name>

<t>The consequence is that the NS, DNSKEY, CDS and CSYNC RRsets are
maintained via a separate piece of software inserted between the zone
owner and the signer. This is referred to as the multi-signer
COMBINER.</t>

<t>The COMBINER has the following features:</t>

<t><list style="symbols">
  <t>It supports inbound zone transfer of the unsigned zone from the
zone owner.</t>
  <t>It receives updates for the NS, DNSKEY, CDS and CSYNC
RRsets from the MSA. Typically the mechanism used is DNS UPDATE
with a TSIG signature, as this is easy to configure in a local
context. However, other mechanisms, including APIs, are possible.</t>
  <t>It stores all data received from the MSA separate from
the zone data received from the zone owner.</t>
  <t>Whenever it receives a new unsigned zone from the zone
owner it COMBINES zone data from the zone owner (the majority of the
zone) with specific zone data under control of the MSA: four
specific RRsets, all in the apex of the zone: the DNSKEY, NS, CDS
and CSYNC RRsets.</t>
  <t>It does not sign the zone.</t>
  <t>It provides outbound zone transfer of the combined zone to the
 signer.</t>
</list></t>

<t>Example setup with two signers showing the logical flow of zone data
between the zone owner, the COMBINER, the signer and the MSA:</t>

<figure><artwork><![CDATA[
                            +--------------+
                            |     owner    |
               xfr          +-+---------+--+    xfr
            /----------------/           \--------------------\
           /                                                   \
    +-----+----+    DNS  +-----+  DNS/API  +-----+  DNS    +----+-----+
    | combiner +<--------+ msa +-----------+ msa +-------->+ combiner |
    +-----+----+  UPDATE +--+--+           +--+--+ UPDATE  +----+-----+
          |                 ^                 ^                 |
          v xfr             |                 |                 v xfr
    +-----+----+     xfr    |                 |   xfr      +----+-----+
    |  signer  +------------+                 +------------+  signer  |
    +-----+----+                                           +----+-----+
          |                                                     |
          v                                                     v
       +--+--+                                               +--+--+
       | NS  |--+                                            | NS  |+
       +-----+  |--+                                         +-----+|-+
          +-----+  |                                            +---+ |
             +-----+                                              +---+
]]></artwork></figure>

</section>
</section>
</section>
<section anchor="communication-between-msas"><name>Communication Between MSAs</name>

<t>Also in the communication case there are two identified
alternatives. The first is to use a REST API between the MSAs and the
second is to use pure DNS communication.</t>

<section anchor="msa-communication-via-rest-api"><name>MSA Communication via REST API</name>

<t>REST APIs are well-known and a natural fit for many distributed
systems. The challenge is mostly in the initial setup of secure
communication. The certificates need to be validated, preferably
without a requirement on trusting a third party CA. The API endpoints
for each MSA need to be located. Once secure communication has been
established, using a REST API for MSA communication is
straight-forward.</t>

</section>
<section anchor="msa-communication-via-dns"><name>MSA Communication via DNS</name>

<t>This alternative is based on the observation that all the
communication needs between MSAs can be expressed via DNS
messages. Notifications are sent as DNS NOTIFY messages. In
Leader/Follower mode requests for changes to a zone are sent as a DNS
UPDATE from the Leader to the Follower. The sole remaining
communication requirement is for how to communicate information about
the current state between MSAs in an ongoing multi-signer
process. This is done via a dedicated EDNS(0) opcode specifically for
communicating multi-signer state. This model is based on
<xref target="!draft-berra…"/> that solves a similar problem for delegation
synchronization between child and parent.</t>

</section>
</section>
<section anchor="identifying-the-designated-signers"><name>Identifying the Designated Signers</name>

<t>It is the responsibility of the zone owner to choose a set of
“signers”, either internal or external to the zone owners
organization. These signers must be clearly and uniquely designated
via publication in the MSIGNER RRset, located at the apex of the zone
and consisting of one MSIGNER record for each signer.</t>

<t>The MSIGNER RRset must be added, by the zone owner, to the, typically
unsigned, zone that the zone owner maintains so that this RRset is
visible to the downstream signers and their multi-signer agents.
6.1. The MSIGNER RRset Yada, yada.</t>

<t>The MSIGNER RR has the zone name that publishes the MSIGNER RRset as
the owner name and the three fields State, Transport and Identity as
RDATA.</t>

<t>zone.    MSIGNER State Transport Identity</t>

<dl>
  <dt>State</dt>
  <dd>
    <t>Unsigned 8-bit. Defined values are 1=ON and 2=OFF. The value 0 is an error.
Values 3-127 are presently undefined. Values 128-255 are reserved for private 
use. The presentation format allows either as integers (1 or 2) or as tokens (“ON” 
or “OFF”).</t>
  </dd>
  <dt>Transport</dt>
  <dd>
    <t>Unsigned 8-bit. Defined values are 1=DNS and 2=API. The value 0 is an error. <br />
Values 3-127 are presently undefined. Values 128-255 are reserved for private 
use. The presentation format allows either as integers (1 or 2) or as tokens 
(“DNS” or “API”).</t>
  </dd>
  <dt>Identity</dt>
  <dd>
    <t>Domain name. Used to uniquely identify the Multi-Signer Agent.</t>
  </dd>
</dl>

<t>Example:</t>

<t>zone.example.   MSIGNER ON API msa.example.</t>

</section>
<section anchor="locating-remote-multi-signer-agents"><name>Locating Remote Multi-Signer Agents</name>

<t>When an MSA receives a zone via zone transfer from the signer it will
analyze the zone to see whether it contains an MSIGNER RRset. If there
is no MSIGNER RRset the zone must be ignored by the MSA from the
point-of-view of multi-signer synchronization.</t>

<t>If, however, the zone does contain an MSIGNER RRset then the MSA must
analyze this RRset to identify the other MSAs for the zone via their
target names in each MSIGNER record. If any of the other MSAs listed
in the MSIGNER RRset is previously unknown to this MSA then secure
communication with this other MSA must be established. The
communication mechanism to use is listed in the MSIGNER record as
either “API” or “DNS”.</t>

<section anchor="locating-a-remote-api-method-multi-signer-agent"><name>Locating a Remote API-Method Multi-Signer Agent</name>

<t>Locating a remote MSA with the identity “msa.example.” using the API
mechanism consists of the following steps:</t>

<t><list style="symbols">
  <t>Lookup and DNSSEC-validate the URI record for
“_https._tcp.msa.example.”. This provides the base URL that will be
used to construct the individual API endpoints for the REST API. It
also provides the port to use.</t>
  <t>Lookup and DNSSEC-validate the SVCB record for the domain name
returned in the response to the URI query
(eg. “api.msa.example.”). This provides the IP-addresses (and
possibly the port, but we already have that) to use for
communication with the MSA.</t>
  <t>Lookup and DNSSEC-validate the TLSA record for
“_{port}._tcp.api.msa.example. This will enable verification of the
certificate of the remote MSA once communication starts.</t>
</list></t>

<t>Example: given the following MSIGNER record for a remote MSA:</t>

<t>zone.example.     IN MSIGNER ON  API msa.provider.com.</t>

<t>the local MSA will look up the URI record for msa.provider.com:</t>

<t>_https._tcp.msa.provider.com.  IN  URI  10 10 “https://api.msa.provider.com:443/api/v2/”
_https._tcp.msa.provider.com.  IN  RRSIG URI …</t>

<t>which triggers a lookup for api.msa.provider.com IPv4 and IPv6
addresses as hints in an SVCB RR:</t>

<t>api.msa.provider.com.   IN  SVCB 1 ipv4hint=1.2.3.4 ipv6hint=2001::bad:cafe:443
api.msa.provider.com.   IN  RRSIG SVCB …</t>

<t>Now we know the IP-address and the port as well as the base URL to
use. Now look up the TLSA record for _443._tcp.api.msa.provider.com,
which may look like this:</t>

<t>_443._tcp.api.msa.provider.com.  IN  TLSA 3 1 1 ….
  _443._tcp.api.msa.provider.com.  IN  RRSIG TLSA …</t>

<t>Once all the DNS lookups and DNSSEC-validation of the returned data
has been done, the local MSA is able to initiate communication with
the remote MSA and verify the identity of the responding party via the
TLSA record for the remote MSAs certificate.</t>

</section>
<section anchor="locating-a-remote-dns-method-multi-signer-agent"><name>Locating a Remote DNS-Method Multi-Signer Agent</name>

<t>Locating a remote MSA using the DNS mechanism consists of the
following steps:</t>

<t><list style="symbols">
  <t>Lookup and DNSSEC-validate the URI record of the MSIGNER
identity. This provides the domain name and port to which DNS
messages should be sent.</t>
  <t>Lookup and DNSSEC-validate the KEY record of the URI record target
name. This enables verification of the SIG(0) public key of the
remote MSA once communication starts.</t>
</list></t>

<t>Example: given the following MSIGNER record for a remote MSA:</t>

<t>zone.example.     IN MSIGNER ON  DNS msa.provider.com.</t>

<t>The local MSA will look up the URI record for msa.provider.com:</t>

<t>_dns._tcp.msa.provider.com.  IN  URI  10 10 “dns://ns.msa.provider.com:5399/”
_dns._tcp.msa.provider.com.  IN  RRSIG URI …</t>

<t>which triggers a lookup for ns.msa.provider.com. SVCB to get the IPv4
and IPv6 addresses as ipv4hints and ipv6hints in the response to the
SVCB query:</t>

<t>ns.msa.provider.com.   IN  SVCB  1 ipv4hint=5.6.7.8 ipv6hint=2001::53
ns.msa.provider.com.   IN RRSIG SVCB …</t>

<t>and also a look up for the KEY record for ns.msa.provider.com, which
may look like this:</t>

<t>ns.msa.provider.com.  IN KEY …
ns.msa.provider.com.  IN RRSIG KEY …</t>

<t>Once all the DNS lookups and DNSSEC-validation of the returned data
has been done, the local MSA is able to initiate communication with
the remote MSA and verify the identity of the responding party via the
validated KEY record for the remote MSAs SIG(0) public key.</t>

</section>
</section>
<section anchor="synchronization-of-changes-between-msas"><name>Synchronization of Changes Between MSAs</name>

<t>There are two defined models for synchronization. The first
(Leader/Follower) has the advantage of more clearly mapping to the
original multi-signer model, with a single controller. The second
model has the advantage of less total communication between MSAs
(including no elections) but the potential disadvantage of more fine
grained communication during the execution of a multi-signer process.</t>

<t>At this stage it is not clear that one model is superior to the other.</t>

<section anchor="leaderfollower-mode"><name>Leader/Follower Mode</name>

<t>In a leader/follower deployment, a designated multi-signer agent
assumes the role of a leader, directing other agents, or followers,
through the multi-signer process state transitions. In this mode it is
necessary to conduct “elections” where one of the MSAs is chosen as
the Leader before initiating a new multi-signer process. Once the
Leader has been chosen, this model is mostly equivalent to the
original multi-signer “model 2”, with a single controller. The other
MSAs (the followers) essentially become proxies between the controller
(the Leader) and the signers.</t>

</section>
<section anchor="peer-mode"><name>Peer Mode</name>

<t>In peer mode, the MSAs still need to locate each other, but instead of
relying on trust in each other, each multi-signer agent operates
independently as a peer. I.e. each MSA executes each step in the
multi-signer process on its own. The communication is essentially
reduced to a notification mechanism (“I am now in state N”), although
authenticated to avoid having the contents of this communication
become an attack vector for an adversary.</t>

</section>
</section>
<section anchor="security-considerations"><name>Security Considerations</name>

<t>...</t>

</section>
<section anchor="iana-considerations"><name>IANA Considerations.</name>

<t>...</t>

<t>--- back</t>

</section>
<section anchor="change-history-to-be-removed-before-publication"><name>Change History (to be removed before publication)</name>

<t><list style="symbols">
  <t>draft-leon-distributed-multi-signer-00</t>
</list></t>

<ul empty="true"><li>
  <t>Initial public draft.</t>
</li></ul>
</section>
